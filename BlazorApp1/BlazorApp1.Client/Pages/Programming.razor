@page "/stands/programming"

@rendermode InteractiveServer
@using BlazorApp1.Client.Models
@using BlazorMonaco
@using System.Runtime.CompilerServices
@using MQTTnet
@using Mqtt
@using MQTTnet.Client
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Code</PageTitle>

<head>
</head>

<h1>Программирование стенда</h1>
<div class="container">
    <div class="row" style="align-content:flex-start">
        <div class="col-md-4">
            <div class="btn-group btn-group-sm">
                <div class="btn-group btn-group-sm">
                    <button class="btn btn-primary" id="start-stream" @onclick=StartStream>Получить трансляцию</button>
                    <button class="btn btn-secondary" id="End-stream" @onclick=StopStream>Остановить трансляцию</button>
                </div>
            </div>
            
            <div class="container card" id="streams">
                <div class="row hide" id="info">
                    <div class="panel panel-default">
                        <div class="panel-heading" style="font-size:large;">
                            <h3 class="panel-title"><i class="fa fa-info-circle"></i></h3>
                        </div>
                        <div class="panel-body">
                            <pre id="metadata" style="word-break: break-word;"></pre>
                        </div>
                    </div>
                </div>
                <div class="col-md" id="videos">
                </div>
            </div>
            <div class="card" style="vertical-align:bottom;">
                <ul class="list-group list-group-flush" style="min-height: 10rem; max-height: 10rem; overflow: auto; align-items:normal;">
                    @foreach (var logEntry in _connectionConsole)
                    {
                        <li class="list-group-item">@logEntry</li>
                    }
                </ul>
            </div>
        </div>
        <div class="col-lg-8">
            <div>
                <StandaloneCodeEditor @ref="_editor"
                                      Id="code-editor"
                                      ConstructionOptions="EditorConstructionOptions" />
            </div>
            <div class="row-md">
                <div class="card">
                    <div class="card-header">
                        Console
                    </div>
                    <ul class="list-group list-group-flush" style="min-height: 7rem; max-height: 12rem; overflow: auto; align-items:normal;">
                        @foreach (var logEntry in _console)
                        {
                            <li class="list-group-item">@logEntry</li>
                        }
                    </ul>
                    <div class="input-group mb3">
                        <input type="text" class="form-control" placeholder="" id="console_input" @bind-value="_consoleInput" />
                        <div class="input-group-prepend">
                            <button class="bt btn-outline-secondary" type="button" @onclick=@SendMessageToConsole>Отправить в консоль</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


@code {
    private string _defaultValue = "";
    private StandaloneEditorConstructionOptions _defaultOptions;
    private IJSObjectReference? _module;

    [System.Diagnostics.CodeAnalysis.AllowNull]
    private StandaloneCodeEditor _editor;

    private List<string> _console { get; set; } = new List<string>();
    private string? _consoleInput { get; set; }

    private List<string> _connectionConsole { get; set; } = new List<string>();

    private IMqttClient? mqttClient { get; set; }

    [SupplyParameterFromQuery]
    public int ID { get; set; }

    public Programming()
    {
        _defaultOptions = new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Language = "c++",
                GlyphMargin = true,
                Value = _defaultValue,
                ScrollBeyondLastLine = false,
                RenderFinalNewline = "on",
                SelectOnLineNumbers = true
            };
    }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneDiffEditor editor)
    {
        return _defaultOptions;
    }

    public void InitJanus()
    {
        JS.InvokeVoidAsync("startJanusStreamModule");
    }

    public void StartStream()
    {
        JS.InvokeVoidAsync("startStream", ID);
    }

    public async Task StopStream()
    {
        await JS.InvokeVoidAsync("stopStream");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InitJanus();
            await InitializeMqttClient();
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task InitializeMqttClient()
    {
        if (mqttClient == null)
        {
            mqttClient ??= new MqttFactory().CreateMqttClient();
            //await MqttClientConnection.Connect_Client_Using_WebSockets(mqttClient);
            await MqttClientConnection.Connect_Client_Using_WebSocketsTls(mqttClient);
            //await MqttClientConnection.Connect_Client_Using_TLS_1_2(mqttClient);
            await MqttSubscribe.Subscribe_Topic(mqttClient, "lab/");
            ConcurrentProcessingDisableAutoAcknowledge(CancellationToken.None, mqttClient);
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Perform async cleanup.
        if (mqttClient != null)
        {
            if (mqttClient.IsConnected)
                await MqttClientConnection.Clean_Disconnect(mqttClient);
            mqttClient.Dispose();
        }

        // Dispose of unmanaged resources.
        _editor.Dispose();

        // Suppress finalization.
        GC.SuppressFinalize(this);
    }

    private async void SendMessageToConsole()
    {
        _console.Add(_consoleInput is null ? "" : _consoleInput);
        if (_consoleInput != null)
            await SendMqttMessage("lab/", _consoleInput);
    }

    private async Task SendMqttMessage(string topic, string value)
    {
        if (mqttClient is not null)
            await MqttClientPublish.Publish_Application_Message(mqttClient, topic, value);
    }

    private async Task SendMqttMessage(MqttMessage message)
    {
        if (mqttClient is not null)
            await MqttClientPublish.Publish_Application_Message(mqttClient, message.Topic, message.Message);
    }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor) => _defaultOptions;

    public static void ConcurrentProcessingDisableAutoAcknowledge(CancellationToken shutdownToken, IMqttClient mqttClient)
    {
        mqttClient.ApplicationMessageReceivedAsync += ea =>
        {
            ea.AutoAcknowledge = false;

            async Task ProcessAsync()
            {
                // DO YOUR WORK HERE!
                // Need to implement responses
                Console.WriteLine(System.Text.Encoding.UTF8.GetString(ea.ApplicationMessage.PayloadSegment));
                await Task.Delay(1000, shutdownToken);
                await ea.AcknowledgeAsync(shutdownToken);
                // WARNING: If process failures are not transient the message will be retried on every restart of the client
                //          A failed message will not be dispatched again to the client as Mqtt does not have a NACK packet to let
                //          the broker know processing failed
                //
                // Optionally: Use a framework like Polly to create a retry policy: https://github.com/App-vNext/Polly#retry
            }

            _ = Task.Run(ProcessAsync, shutdownToken);

            return Task.CompletedTask;
        };
    }
}